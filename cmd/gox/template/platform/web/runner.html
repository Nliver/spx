<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport"
		content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
	<title>XGo Builder</title>
	<style>
		html,
		body {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
			display: flex;
			justify-content: center;
			align-items: center;
			background: transparent;
			background-color: transparent;
			overflow: hidden;
		}

		canvas {
			display: block;
			margin: 0;
			outline: none;
		}
	</style>
</head>

<body>
	<div id="tabs">
		<div id="tab-loader">
		</div>
		<div id="tab-editor" style="display: none;">
			<canvas id="editor-canvas" tabindex="1"></canvas>
		</div>
		<div id="tab-game" style="display: none;">
			<canvas id="game-canvas" tabindex="2"></canvas>
		</div>
	</div>
	<script>var miniEngine = null</script>
	<script>var isWasmCompressed = false</script>
	<script src="go.wasm.exec.js"></script>
	<script src="storage.manager.js"></script>
	<script src="worker.message.manager.js"></script>
	<script src="engine.js"></script>
	<script src="game.js"></script>
	<script>
		"use strict";
		let gameApp = null
		let isShowEditor = false

		let lastAssetURLs = null
		let lastConfig = null

		window.spxIsProxyThreadMode = false

		function onProgress(value) {
			const progressEvent = new CustomEvent('onProgress', {
				detail: {
					progress: value
				}
			});
			window.dispatchEvent(progressEvent);
			if (value >= 1) {
				document.getElementById('tab-game').style.display = 'none';
				document.getElementById('tab-editor').style.display = 'none';
				document.getElementById('tab-loader').style.display = 'none';
				let canvas = null
				if (gameApp.isEditor) {
					if (isShowEditor) {
						document.getElementById('tab-editor').style.display = 'block';
					}
					canvas = document.getElementById('editor-canvas')
				} else {
					document.getElementById('tab-game').style.display = 'block';
					canvas = document.getElementById('game-canvas')
				}
				canvas.width = window.innerWidth;
				canvas.height = window.innerHeight;
			}
		}

		async function handleGodotExit(code) {
            await restartEngineAfterCrash("godot exit", code);
        }

		let restartAttempts = 0;
		let onGameError = null
		let onGameExit = null
		let onRestartFailed = null;
		const MAX_RESTART_ATTEMPTS = 3;
		async function restartEngineAfterCrash(reason, code) {
			if (restartAttempts >= MAX_RESTART_ATTEMPTS) {
				console.error("Max restart attempts reached.  Please reload manually.");
				if (onRestartFailed != null) {
					onRestartFailed(`Crash detected. Reason: ${reason}, Exit code: ${code}`)
				}
				return;
			}
			restartAttempts++;

			console.warn(`Crash detected. Reason: ${reason}, Exit code: ${code}`);
			gameApp = null;
			try {
				await window.initEngine(lastAssetURLs, lastConfig);
				restartAttempts = 0; 
				console.log("Engine reinitialized.");
			} catch (e) {
				console.error("Engine re-init failed:", e);
			}
		}

		window.onGameError = function (callback) {
			onGameError = callback
		}
		window.onGameExit = function (callback) {
			onGameExit = callback
		}
		window.onRestartFailed = function (callback) {
			onRestartFailed = callback
		}

		window.gdspx_on_runtime_panic = function (msg) {
			if (onGameError != null) {
				onGameError(msg)
			}
		}

		window.gdspx_on_runtime_exit = async (code) => {
			await restartEngineAfterCrash("runtime exit", code);
		}

		window.onGoWasmExit = async (code) => {
			await restartEngineAfterCrash("go wasm exit", code);
		}

		window.gdspx_on_runtime_reset = async (code) => {
			if (onGameExit != null) {
				onGameExit(code)
			}
		}

		window.addEventListener("godot-wasm-crash", async e => {
			await restartEngineAfterCrash("godot crash", e.detail);
		})

		window.initEngine = async (assetURLs = null, config = {}) => {
			isShowEditor = false
			
			if (gameApp != null) {
				await gameApp.ResetGame();
				return;
			}

			if(EnginePackMode == "worker"){
				window.setAIDescription = function (description) {
					gameApp.callWorkerFunction("setAIDescription", description)
				}
				window.setAIInteractionAPIEndpoint = function (endpoint) {
					gameApp.callWorkerFunction("setAIInteractionAPIEndpoint", endpoint)
				}
				window.setAIInteractionAPITokenProvider = function (tokenProviderFunction) {
					gameApp.callWorkerFunction("setAIInteractionAPITokenProvider", tokenProviderFunction)
				}

				window.onWasmLoaded = function () {}
				window.onGameStarted = function () {}
			}
			
			const finalConfig = {
				'projectName': "spx_game",
				'onProgress': onProgress,
				'handleGodotExit': handleGodotExit,
				"gameCanvas": document.getElementById('game-canvas'),
				"logLevel": LOG_LEVEL_NONE,
				"useAssetCache": false,
				"isRuntimeMode": true,
				"assetURLs": {
					"engine.zip": "/engine.zip",
					"game.zip": "/game.zip",
					"gdspx.wasm": "/gdspx.wasm",
					"engine.wasm": "/engine.wasm",
				},
				"recordingOnGameStart": false,
				"autoDownloadRecordedVideo": false,
			};
			
			if (assetURLs != null) {
				finalConfig.assetURLs = assetURLs
			}

			lastAssetURLs = assetURLs
			lastConfig = config
			Object.assign(finalConfig, config);
			gameApp = new GameApp(finalConfig);
			await gameApp.InitEngine();
		}

		window.initGame = async (files) => {
			if (gameApp == null) throw new Error("gameApp is null, should call initEngine first")
			await gameApp.InitGame(files)
		}
		
		window.startGame = async () => {
			if (gameApp == null) throw new Error("gameApp is null, should call initEngine first")
			await gameApp.StartGame();
		}

		// Starts recording the game canvas content as video
		window.startRecording = () => {
			if (gameApp == null) {
				console.error("gameApp is null, should call startGame first")
				return
			}
			gameApp.startRecording()
		}
		
		// Stops the current recording session and returns the result as a Blob.
		window.stopRecording = async () => {
			if (gameApp == null) {
				console.error("gameApp is null, should call startGame first")
				return
			}
			return await gameApp.stopRecording()
		}

		// Returns the recorded video as a Blob.
		window.getRecordedVideo = () => {
			if (gameApp == null) {
				console.error("gameApp is null, should call startGame first")
				return null
			}
			return gameApp.getRecordedVideo()
		}

		// Captures the current game screen and returns its binary data as a Blob.
		window.getScreenshot = async () => {
			let gameCanvas = document.getElementById('game-canvas')
			if (!gameCanvas) {
				console.error("gameCanvas not found")
				return null
			}
			if (!gameCanvas.toBlob) {
				console.error("gameCanvas.toBlob not supported")
				return null
			}
			return new Promise((resolve) => {
				gameCanvas.toBlob((blob) => {
					resolve(blob)
				}, 'image/png')
			})
		}

		window.downloadRecordedVideo = (filename) => {
			if (gameApp == null) {
				console.error("gameApp is null, should call startGame first")
				return null
			}
			gameApp.downloadRecordedVideo(filename)
		}

		window.stopGame = async () => {
			if (gameApp == null) {
				console.error("gameApp is null, should call startGame first")
				return
			}
			await gameApp.ResetGame();
		}

		window.pauseGame = () => {
			if (gameApp == null) {
				console.error("gameApp is null, should call startGame first")
				return
			}
			gameApp.pause();
		}

		window.resumeGame = () => {
			if (gameApp == null) {
				console.error("gameApp is null, should call startGame first")
				return
			}
			gameApp.resume();
		}

		window.stepNextFrame = () => {
			if (gameApp == null) {
				console.error("gameApp is null, should call startGame first")
				return
			}
			gameApp.stepNextFrame();
		}
		
		// Inform the parent window that the runner is ready (methods on the window object are callable)
		window.dispatchEvent(new Event('runnerReady'));
	</script>
</body>

</html>
